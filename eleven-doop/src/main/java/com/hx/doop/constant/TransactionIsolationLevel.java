package com.hx.doop.constant;

/**
 * 事务隔离级别
 * @author wml
 * @date   2024/03/14
 */
public interface TransactionIsolationLevel {


	/**
	 * 不支持事务的常量。
	 */
	int TRANSACTION_NONE             = 0;
	/**
	 * 可读未提交事务数据：一个事务可以读取另一个事务已修改但未提交的数据，
	 * 可能发生脏读、不可重复读和幻读的常数。这个级别允许被一个事务更改的行在该行的任何更改被提交之前被另一个事务读取(“脏读”)。
	 * 如果回滚任何更改，则第二个事务将检索到无效行。
	 */
	int TRANSACTION_READ_UNCOMMITTED = 1;
	/**
	 * 只能读提交事务数据：一个事务只能读取另一个事务已经提交的数据。
	 * 这种隔离级别解决了脏读问题，但可能存在不可重复读（Non-repeatable Read）或者幻读问题；
	 * 不可重复读：即在同一事务内多次读取同一数据可能会得到不同的结果。
	 *
	 */
	int TRANSACTION_READ_COMMITTED   = 2;
	/**
	 * 可重复读(已提交事务)：保证在同一事务内多次读取同一数据时，得到的结果始终一致。这种隔离级别解决了不可重复读问题，
	 * 但可能存在幻读（Phantom Read）问题，即在同一事务内多次执行查询，得到的结果集不一致。
	 * 该级别禁止事务读取未提交更改的行，还禁止出现这样的情况:
	 * 一个事务读取一行，第二个事务更改该行，第一个事务重新读取该行，第二次读取时得到不同的值(“不可重复读取”)。
	 */
	int TRANSACTION_REPEATABLE_READ  = 4;
	/**
	 * 串行化（Serializable）：所有的事务顺序执行，确保事务串行执行，避免并发问题。这种隔离级别解决了幻读问题，
	 * 但在高并发情况下会导致性能下降，因为事务需要串行执行。
	 * 需要注意，隔离级别从上到下，并发性能越来越差，但对于数据的隔离性一致性保证程度越好。
	 *
	 * 指示脏读、不可重复读和虚读被阻止的常数。该级别包括TRANSACTION_REPEATABLE_READ中的禁止，
	 * 并进一步禁止以下情况:一个事务读取满足where条件的所有行，第二个事务插入满足where条件的行，
	 * 第一个事务为相同的条件重新读取，在第二次读取中检索额外的“幻影”行。
	 */
	int TRANSACTION_SERIALIZABLE     = 8;
}
